# include "vec2.bzz"

# Random Walk parameters
SPEED = 100
MAX_ANGULAR = 0.9
MAX_STEPS_RANDOM = 40

# Obstacle Avoidance Parameters
THRESHOLD = 0.0
ANGULAR_SPEED_AVOID = 1.0
NUM_ROBOTS = 10
DISTANCE_THRESHOLD = 1.0

# Leave Nest Parameters
NEST_THRESHOLD = 0.1

# FSM Parameters
VOID_ZONE = 0
DANGER_ZONE = 2
FOOD_ZONE = 1
NEST_ZONE = 3

# Energy parameters
INIT_ENERGY = 1000
ENERGY_FOOD = 1000


function init() {
	math.rng.setseed(id)
	has_food = 0
	is_stuck = 0
	energy = INIT_ENERGY
	reset_random_walk()

	s = swarm.create(0)
	s.join()
	map = {}
	neighbors.listen("danger_zone",
		function(vid, value, rid) {
			logg(rid, 0)
			map.rid = value
		}
	)
}

function step() {

	# If we are stuck, not allowed to do any action
	if (is_stuck) {
		return
	}

	# Energy expenditure
	energy = energy - 1
	if (energy <= 0) {
		is_stuck = 1
		set_wheels(0.0, 0.0)
		return 
	}

	current_zone = get_zone(id)
	# If we are in the base, drop food and rotate until we face right
	if (current_zone == NEST_ZONE) {
		# Drop food if we have any
		drop_food()
		# Rotate until facing right
		leave_nest()
	} else if (current_zone == DANGER_ZONE) {
		# Get stuck and send location to neighbours
		set_wheels(0.0, 0.0)
		neighbors.broadcast("danger_zone", pose.position.x)# {.x = pose.position.x, .y = pose.position.y})
		neighbors.ignore("danger_zone")
		is_stuck = 1
	} else if (current_zone == FOOD_ZONE or has_food > 0) { 
		# Pick Up food and rotate to left to go back to nest
		if (current_zone == FOOD_ZONE) {
			has_food = has_food + 1
		}
		move_with_avoidance(goto_nest)
	} else if (current_zone == VOID_ZONE) {
		# Walk randomly looking for food
		move_with_avoidance(random_walk)
	}
}


# Rotate robot until facing to the left and return to nest
function goto_nest() {
	if ((pose.orientation.yaw < 3.0) and (pose.orientation.yaw > -3.0)) { 
		if (pose.orientation.yaw < 0) {
			set_wheels(10.0, -5.0)
		} else {
			set_wheels(-5.0, 10.0)
		}
	} else {
		gotop(SPEED, 0.0)
	}
}

# Get out of the nest by rotating towards the right and going straight
function leave_nest() {
	if (pose.orientation.yaw > NEST_THRESHOLD or pose.orientation.yaw < -NEST_THRESHOLD) { 
		if (pose.orientation.yaw < 0) {
			set_wheels(-10.0, 10.0)
		} else {
			set_wheels(10.0, -10.0)
		}
	} else {
		gotop(SPEED, 0.0)
	}
}

# Drop food and gain energy
function drop_food() {
	if (has_food) {
		energy = energy + has_food * ENERGY_FOOD
		has_food = 0
	}
}


# Perform a random walk with obstacle avoidance
function move_with_avoidance(desired_move) {

	index = check_avoidance()
	if (index == -1) {
		danger_zone = check_danger_zone()
		if (danger_zone.x != 1000.0 and danger_zone.y != 1000.0) {
			forward_vec = {.x = math.cos(pose.orientation.yaw), .y = math.sin(pose.orientation.yaw)}
			current_pose = {.x = pose.position.x, .y = pose.position.y}
			cross = vec_cross(vec_sub(forward, current_pose), vec_sub(danger_zone, current_pose))
			if (cross > 0) {
				angular_vel_avoid = -ANGULAR_SPEED_AVOID
			} else {
				angular_vel_avoid = ANGULAR_SPEED_AVOID
			}
			gotop(SPEED / 4.0, angular_vel_avoid)
		} else {
			desired_move()
		}
	} else {
		if (index < 4) {
			angular_vel_avoid = -ANGULAR_SPEED_AVOID
		} else {
			angular_vel_avoid = ANGULAR_SPEED_AVOID
		}
		gotop(SPEED / 4.0, angular_vel_avoid)
	}
}

function check_danger_zone() {
	var smallest_distance = 1000.0
	var closest_point = {.x = 1000.0, .y = 1000.0}
	for (i=0, i<NUM_ROBOTS, i=i+1) {
		if (i != id) {
			danger_zone = map[i]
			if (danger_zone != nil) {
				dist = vec_distance(danger_zone, {.x = pose.position.x, .y = pose.position.y})
				if (dist < smallest_distance and dist < DISTANCE_THRESHOLD) {
					smallest_distance = dist
					closest_point = danger_zone
				}
			}
		}
	}
	return closest_point
}

function vec_cross(vec_1, vec_2) {
	return (vec_1.x * vec_2.y) - (vec_1.y * vec_2.x)
}

function vec_sub(vec_1, vec_2) {
	return {.x = vec_1.x - vec_2.y, .y = vec_1.y - vec_2.y}
}

function vec_distance(vec_1, vec_2) {
	return math.sqrt((vec_1.x - vec_2.x) * (vec_1.x - vec_2.x) + (vec_1.y - vec_2.y) * (vec_1.y - vec_2.y))
}

# Action to move according to a Random Walk
function random_walk() {
  random_steps = random_steps + 1
  if (random_steps <= next_random_update) {
    current_angular_vel = angular_vel * gaussian(random_steps - (next_random_update / 2))
  } else {
    current_angular_vel = reset_random_walk()
  }
  gotop(SPEED, current_angular_vel)
}

# Function to reset random walk
function reset_random_walk() {
  next_random_update = math.rng.uniform(MAX_STEPS_RANDOM-10, MAX_STEPS_RANDOM)
  angular_vel = math.rng.uniform(-MAX_ANGULAR, MAX_ANGULAR)
  random_steps = 0
  return angular_vel
}

# Find the nearest obstacle and turn accordingly
function check_avoidance() {
	max_val = THRESHOLD
	max_idx = -1

	for (i=0, i<8, i=i+1) {
		if (proximity[i].value > max_val) {
			max_val = proximity[i].value
			max_idx = i
		}
	}
	return max_idx
}

# Compute a gaussian centered at 0, with std c and height 1
function gaussian(x) {
  a = 1.0
  c = 10.0
  res = math.exp(-(x * x) / (2.0 * c * c))
  return res
}

# Log only for a specific robot
function logg(str, rid) {
  if (id == rid) {
    log(str)
  }
}

function reset() {}

function destroy() {}
